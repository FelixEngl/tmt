use std::cmp::max;
use std::collections::hash_map::Entry;
use std::collections::{HashMap, HashSet};
use std::fs;
use std::io::{Read, Seek};
use std::path::PathBuf;
use pyo3_stub_gen::{Result, StubInfo};
use pyo3_stub_gen::generate::{Import, Module};
use ldatranslate::toolkit::pystub::*;

fn main() -> Result<()> {
    env_logger::Builder::from_env(env_logger::Env::default().filter_or("RUST_LOG", "trace")).init();
    let mut stub = ldatranslate::stub_info()?;
    stub.generate()?;
    generate_typedefs(&mut stub)?;
    Ok(())
}

fn generate_typedefs(stub: &mut StubInfo) -> Result<()>{
    let python_root = stub
        .pyproject
        .python_source()
        .unwrap_or(PathBuf::from(std::env::var("CARGO_MANIFEST_DIR")?));

    let mut imports = HashSet::new();
    for module in stub.modules.values() {
        imports.extend(module.import());
    }

    let mut modules = HashMap::new();
    for info in inventory::iter::<PyTypeInfo> {
        let (is_empty, path, module_default) = if let Some(module) = info.module {
            let (is_empty, module_default) = match stub.modules.entry(module.to_string()) {
                std::collections::btree_map::Entry::Vacant(value) => {
                    let mut x = Module::default();
                    x.name = module.to_string();
                    let def = stub.pyproject.module_name().to_string();
                    x.default_module_name = def.clone();
                    value.insert(x);
                    (true, def)
                }
                std::collections::btree_map::Entry::Occupied(value) => {
                    let x  = value.get();
                    (x.submodules.is_empty(), x.default_module_name.clone())
                }
            };
            (is_empty, module.replace('.', "/"), module_default)
        } else {
            let m = stub.modules.get(stub.pyproject.module_name()).unwrap();
            (m.submodules.is_empty(), stub.pyproject.module_name().replace('.', "/"), m.default_module_name.clone())
        };

        let dest = if is_empty {
            python_root.join(format!("{path}.pyi"))
        } else {
            python_root.join(&path).join("__init__.pyi")
        };

        match modules.entry(path) {
            Entry::Vacant(value) => {
                value.insert(
                    (is_empty, dest, module_default, vec![PyTypeDef::from(info)])
                );
            }
            Entry::Occupied(mut value) => {
                value.get_mut().3.push(
                    PyTypeDef::from(info)
                );
            }
        }
    }


   for (_, (_, dest, module_default, infos)) in modules {
       let dir = dest.parent().expect("Needs a parent");
       if !dir.exists() {
           fs::create_dir_all(dir)?;
       }

       let mut f = fs::File::options()
           .read(true)
           .write(true)
           .create(true)
           .open(&dest)?;

       let f_len = f.metadata()?.len() as usize;

       let mut new_content = String::with_capacity(f_len);

       let mut content = String::with_capacity(f_len);

       if f_len != 0 {
           f.read_to_string(&mut content)?;
           ldatranslate::define_aho_matcher!(
               static IMPORT = " import " | "\nimport "
           );

           if let Some(found) = IMPORT.find_iter(&content).last() {
               let end = found.end();
               let to_consume = content[end..].find('\n').expect("There should be a newline!");
               new_content.extend(content.drain(..=to_consume + end));
           }
       }

       use std::io::Write;
       use std::fmt::Write as W2;

       for info in infos.iter() {
           for v in &info.type_.import {
               if imports.insert(v.clone()) {
                   if let Some(v) = v.get() {
                       writeln!(new_content, "import {}", v)?;
                   } else {
                       writeln!(new_content, "import {}", module_default)?;
                   }
               }
           }
       }

       writeln!(new_content, "\n\n# Autogenerated types for recursions etc.")?;

       for value in infos {
           writeln!(new_content, "{}", value)?;
       }
       write!(new_content, "\n")?;

       new_content.push_str(&content);
       drop(content);
       f.rewind()?;
       write!(f, "{new_content}")?;
   }

    "def search(self, query:str | list[str] | typing.Callable[[LanguageKind, str], bool], search_type:typing.Optional[SearchTypeUnionType], threshold:typing.Optional[int | float], target_language:typing.Optional[LanguageKind], ignores_ascii_case:typing.Optional[bool]) -> SearchResultContainerType:";

    Ok(())
}